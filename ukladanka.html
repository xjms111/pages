<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Układanka obrazkowa</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      padding: 20px;
      background: #f4f4f4;
    }

    canvas {
      border: 2px solid #333;
      margin-top: 20px;
      touch-action: manipulation;
      image-rendering: pixelated;
    }

    input, select, button {
      margin: 10px;
      padding: 8px;
      font-size: 1rem;
    }

    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    @media (min-width: 600px) {
      .controls {
        flex-direction: row;
        justify-content: center;
      }
    }

    .highlight {
      outline: 2px solid red;
    }
  </style>
</head>
<body>
  <h1>Układanka obrazkowa</h1>
  <div class="controls">
    <input type="file" id="imageInput" accept="image/*" />
    <label for="size">Rozmiar:</label>
    <select id="size">
      <option value="3">3x3</option>
      <option value="4">4x4</option>
      <option value="5">5x5</option>
    </select>
    <button id="startBtn">Nowa gra</button>
    <button id="resetBtn">Wczytaj ostatnią</button>
  </div>
  <canvas id="puzzleCanvas" width="450" height="450"></canvas>

  <script>
    /*jslint browser */
    /*global Image */

    const canvas = document.getElementById("puzzleCanvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    ctx.imageSmoothingEnabled = false;

    const imageInput = document.getElementById("imageInput");
    const sizeSelect = document.getElementById("size");
    const startBtn = document.getElementById("startBtn");
    const resetBtn = document.getElementById("resetBtn");

    let image = new Image();
    let gridSize = 3;
    let tiles = [];
    let emptyTile = { row: 0, col: 0 };
    let imgDataUrl = "";
    let pieceWidth, pieceHeight;

    function saveState() {
      const state = {
        imgDataUrl: imgDataUrl,
        gridSize: gridSize,
        tiles: tiles,
        emptyTile: emptyTile
      };
      localStorage.setItem("puzzleState", JSON.stringify(state));
    }

    function loadState() {
      const state = JSON.parse(localStorage.getItem("puzzleState"));
      if (!state) return;
      imgDataUrl = state.imgDataUrl;
      gridSize = state.gridSize;
      tiles = state.tiles;
      emptyTile = state.emptyTile;
      sizeSelect.value = gridSize;

      image.onload = () => {
        drawPuzzle();
      };
      image.src = imgDataUrl;
    }

    function initTiles() {
      tiles = [];
      for (let i = 0; i < gridSize * gridSize; i++) {
        tiles.push(i);
      }

      // Fisher–Yates shuffle
      for (let i = tiles.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
      }

      // Ensure solvable
      tiles[0] = -1; // empty tile
      emptyTile = { row: 0, col: 0 };
    }

    function drawPuzzle() {
      canvas.width = 450;
      canvas.height = 450;
      pieceWidth = canvas.width / gridSize;
      pieceHeight = canvas.height / gridSize;

      for (let i = 0; i < tiles.length; i++) {
        const val = tiles[i];
        const row = Math.floor(i / gridSize);
        const col = i % gridSize;

        if (val === -1) {
          ctx.fillStyle = "blue";
          ctx.fillRect(col * pieceWidth, row * pieceHeight, pieceWidth, pieceHeight);
        } else {
          const srcRow = Math.floor(val / gridSize);
          const srcCol = val % gridSize;

          ctx.drawImage(
            image,
            srcCol * (image.width / gridSize),
            srcRow * (image.height / gridSize),
            image.width / gridSize,
            image.height / gridSize,
            col * pieceWidth,
            row * pieceHeight,
            pieceWidth,
            pieceHeight
          );
        }
      }

      saveState();
    }

    function getTileAt(x, y) {
      const col = Math.floor(x / pieceWidth);
      const row = Math.floor(y / pieceHeight);
      return { row, col };
    }

    function isAdjacent(row, col) {
      const dx = Math.abs(emptyTile.col - col);
      const dy = Math.abs(emptyTile.row - row);
      return (dx + dy === 1);
    }

    function swapTiles(row, col) {
      const fromIndex = row * gridSize + col;
      const toIndex = emptyTile.row * gridSize + emptyTile.col;

      [tiles[fromIndex], tiles[toIndex]] = [tiles[toIndex], tiles[fromIndex]];
      emptyTile = { row, col };
      drawPuzzle();

      if (checkWin()) {
        setTimeout(() => {
          alert("Gratulacje! Ułożyłeś obrazek!");
          localStorage.removeItem("puzzleState");
        }, 300);
      }
    }

    function checkWin() {
      for (let i = 1; i < tiles.length; i++) {
        if (tiles[i] !== i) return false;
      }
      return tiles[0] === -1;
    }

    canvas.addEventListener("click", function (e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const { row, col } = getTileAt(x, y);

      if (isAdjacent(row, col)) {
        swapTiles(row, col);
      }
    });

    canvas.addEventListener("touchstart", function (e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      const { row, col } = getTileAt(x, y);

      if (isAdjacent(row, col)) {
        swapTiles(row, col);
      }
    });

    startBtn.addEventListener("click", function () {
      gridSize = parseInt(sizeSelect.value, 10);
      if (image.src) {
        initTiles();
        drawPuzzle();
      }
    });

    resetBtn.addEventListener("click", function () {
      loadState();
    });

    imageInput.addEventListener("change", function () {
      const file = imageInput.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          imgDataUrl = e.target.result;
          image.onload = () => {
            initTiles();
            drawPuzzle();
          };
          image.src = imgDataUrl;
        };
        reader.readAsDataURL(file);
      }
    });

    window.addEventListener("load", () => {
      const state = localStorage.getItem("puzzleState");
      if (state) {
        loadState();
      } else {
        image.src = "default.jpg"; // Możesz dodać domyślny obrazek
        image.onload = () => {
          initTiles();
          drawPuzzle();
        };
        imgDataUrl = image.src;
      }
    });
  </script>
</body>
</html>

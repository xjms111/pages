<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Układanka obrazkowa</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    canvas {
      margin-top: 20px;
      border: 2px solid #333;
      touch-action: none;
    }
    input, select, button {
      margin: 5px;
    }
  </style>
</head>
<body>
  <h1>Układanka obrazkowa</h1>
  <input type="file" id="fileInput" accept="image/*" />
  <label>Rozmiar:
    <select id="sizeSelect">
      <option value="3">3x3</option>
      <option value="4">4x4</option>
      <option value="5">5x5</option>
    </select>
  </label>
  <button id="startButton">Start</button>
  <button id="resetButton">Reset</button>

  <canvas id="puzzle" width="600" height="600"></canvas>

  <script>
    const canvas = document.getElementById("puzzle");
    const ctx = canvas.getContext("2d");
    const fileInput = document.getElementById("fileInput");
    const sizeSelect = document.getElementById("sizeSelect");
    const startButton = document.getElementById("startButton");
    const resetButton = document.getElementById("resetButton");

    let img = new Image();
    let gridSize = 3;
    let tiles = [];
    let emptyTile = { x: 0, y: 0 };
    let tileSize;
    let imgDataUrl = "";

    function drawPuzzle() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      tiles.forEach(tile => {
        if (!(tile.x === emptyTile.x && tile.y === emptyTile.y)) {
          ctx.drawImage(
            img,
            tile.srcX * tileSize,
            tile.srcY * tileSize,
            tileSize,
            tileSize,
            tile.x * tileSize,
            tile.y * tileSize,
            tileSize,
            tileSize
          );
        } else {
          ctx.fillStyle = "blue";
          ctx.fillRect(tile.x * tileSize, tile.y * tileSize, tileSize, tileSize);
        }
      });
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function saveState() {
      const state = {
        gridSize,
        tiles,
        emptyTile,
        imgDataUrl,
      };
      localStorage.setItem("puzzleState", JSON.stringify(state));
    }

    function loadState() {
      const saved = localStorage.getItem("puzzleState");
      if (!saved) return false;
      const state = JSON.parse(saved);
      gridSize = state.gridSize;
      tiles = state.tiles;
      emptyTile = state.emptyTile;
      imgDataUrl = state.imgDataUrl;
      sizeSelect.value = gridSize;
      img.onload = () => {
        tileSize = canvas.width / gridSize;
        drawPuzzle();
      };
      img.src = imgDataUrl;
      return true;
    }

    function setupPuzzle() {
      tileSize = canvas.width / gridSize;
      tiles = [];
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          tiles.push({ x, y, srcX: x, srcY: y });
        }
      }
      shuffle(tiles);
      tiles.forEach((tile, i) => {
        tile.x = i % gridSize;
        tile.y = Math.floor(i / gridSize);
      });
      emptyTile = tiles[0];
      drawPuzzle();
      saveState();
    }

    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / tileSize);
      const y = Math.floor((e.clientY - rect.top) / tileSize);
      const clicked = tiles.find(t => t.x === x && t.y === y);
      if (clicked && isAdjacent(clicked, emptyTile)) {
        const temp = { x: clicked.x, y: clicked.y };
        clicked.x = emptyTile.x;
        clicked.y = emptyTile.y;
        emptyTile.x = temp.x;
        emptyTile.y = temp.y;
        drawPuzzle();
        saveState();
      }
    });

    function isAdjacent(a, b) {
      return (
        (a.x === b.x && Math.abs(a.y - b.y) === 1) ||
        (a.y === b.y && Math.abs(a.x - b.x) === 1)
      );
    }

    startButton.addEventListener("click", () => {
      gridSize = parseInt(sizeSelect.value, 10);
      if (!img.src) {
        img.src = "default.jpg";
        img.onload = () => {
          imgDataUrl = canvas.toDataURL("image/jpeg");
          setupPuzzle();
        };
      } else {
        setupPuzzle();
      }
    });

    fileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (event) {
        img.src = event.target.result;
        imgDataUrl = event.target.result;
        img.onload = () => {
          setupPuzzle();
        };
      };
      reader.readAsDataURL(file);
    });

    resetButton.addEventListener("click", () => {
      localStorage.removeItem("puzzleState");
      location.reload();
    });

    window.addEventListener("load", () => {
      if (!loadState()) {
        img.src = "default.jpg";
        img.onload = () => {
          imgDataUrl = canvas.toDataURL("image/jpeg");
          setupPuzzle();
        };
      }
    });
  </script>
</body>
</html>
